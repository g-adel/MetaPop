\section{Simulation}
Accurate and efficient simulation is a critical component of this project, as the study of adaptive containment strategies for epidemics in metapopulation networks relies on robust numerical methods. The underlying system of ODEs demands precise integration schemes to capture both quantitative and qualitative dynamics accurately. Simultaneously, the large size of the networks and the need for ensemble simulations require computationally efficient algorithms and data structures.\\

This chapter outlines the numerical methods employed to analyze the system's dynamics across various configurations and network structures. It includes a discussion of the tools, data structures, numerical solvers, data processing, and visualization techniques used. Special attention is given to the integration schemes, as trivial methods necessitate impractically small time steps to maintain accuracy, leading to poor performance and significant errors. Improved solvers were implemented to achieve better error scaling with respect to the time step.\\

Furthermore, efficient data structures and algorithms were developed to address scaling challenges posed by large networks. This requirement was amplified by multi-step integration schemes, which necessitate managing multiple concurrent states of the network. The combined focus on accuracy and efficiency ensures that the simulations can effectively support the analysis of adaptive epidemic containment strategies.\\

\subsection{ODE System Properties}
When solving an ODE, it is critical to first understand its type and properties, as different require different integration or solver schemes. The entire system of ODE system is represented in the set of infection dynamics and travel restriction equations [insert equation numbers here].\\

Based on the design of the model, it is expected that at all times, the sum of all compartments of individuals in all subpopulations should remain constant. Furthermore, due to the formulation of the mobility rates between subpopulations, it is expected that the total number of individuals at each subpopulation is also conserved. \\

There are many possible cases in which the ODE becomes stiff. Stiff ODEs are ones in which different variables change on different timescales. In the case of this model, possible cases include: Infection rates are much faster than recovery rates, the mobility matrix $\Delta$ has very different time scales, and population sizes vary significantly between subpopulations. However, with somewhat realisitic model parameters, these disparagements do not cause significant stiffness. The two major sources of stiffness that can be found in the ODE and have been observed in the numerical simulation are:
\begin{itemize}
	\item \textbf{Fast infection spread in the wavefront:} In both the adaptive and non-adaptive system, it is found that the infection spreads in wave at a somewhat constant speed. This wave is characterized by consecutive rapid spread of infection in subpopulations based on how far away in the network from the initial infection. This causes step-wise process where at any point in time a small group of the metapopulation having very rapid internal spread of infection while the remainder of the subpopulations have already been infected or are yet to be sufficiently infected. This translates to wildly different rates of change number of infecteds in the different metapopulations, which contributes stiffness to the system.
	\item \textbf{Fast travel restriction in the wavefront:} In the adaptive system, it was found that the proportionality constant for the  travel restriction, $\lambda$, needs to be sufficiently high to have an effective slow-down of the infection spread across the network. However, this causes travel restriction to change on a much faster than the infection variables especially around the wavefront. This adds another source of stiffness to the model. 
    
\end{itemize}

Based on the structure of the ODE, one can also prove that the solution should lie within a certain system domain which it is unable to escape. Examples of boudaries of this manifold include the size of any infection compartment becoming negative or surpassing the total subpopulation size, and travel restrictions being restricted in the range from 0 to 1. Besides the fact that a numerical solution exceding these boundaries is an obvious sign that the integration scheme is erroneous, exiting this domain could result in numerical oscillations or even divergence from the solution entirely. An example of this is travel restriction turning negative which would result in it having a negative rate of change, causing exponential growth in the negative direction.\\

There are several sources of nonlinearity in this system of ODEs, such as the $S_{x} I_{x}$ term in infection spread, and $\bar \rho I_{x}$ in travel restriction. Nonlinear terms can lead to numerical instabilities, exacerbate error propagation, among other things. Simple integration schemes that do not take into consideration accuracy and stability would be prone to errors. Furthermore, nonlinear systems often require iterative solvers for implicit methods, increasing computational cost, especially with large-scale systems.\\

It is also worth to keep in mind the level of sparsity in the adjacency matrix as it impacts the expected scaling of computational cost with network size. With sufficienty large matrices, it can be expected that the total computation time will asymptotically approach the scaling of number of links in the network, For sparse and scale-free networks, this scaling can be close to linear, causing little concern for computational cost scaling with large networks.\\

However, another trait of the topology, the degree distribution, also plays a role in the computational cost. In particular, parallelizability of the code can suffer significantly from work imbalance. Since the numerical integrator iterates over nodes, and not links, it is sensetive to the heterogeniety of the degree distribution. For example, in scale-free networks, highly connected nodes (called hubs) can have orders of magnitude more links than the nodes on the perefery. This heterogeniety can make parallizing the code, where each process or thread finds the rate of change for only a select group of nodes, have imbalanced work distribution, possibly slowing down the computation to the worst-case-scenario for a single thread. This can be at least partially remedied by finding a mapping that minimizes the total number of links each thread is responsible for, which is by itself a non-trivial problem.\\

Another property of the ODE to take into consideration is high variance in rates of change as this causes huge inefficiencies in computation if inappropriate solvers are used. It can be observed that given the non-zero initial condition of the number of infecteds of the first infected subpopulation. Due to the required high value of $\lambda$, initial growth of the immediate neighbors of the infected subpopulation can have arbitrarily high growth rate of the travel restriction. This is in contrast to the much lower rates of change for all subsequently infected subpopulations, as they react to incoming infecteds that start and grow continuously from an initial condition of zero infected.\\


\subsection{Numerical Simulation}
\subsubsection{Language and Tools}
The Julia programming language was used for the computational aspect of this project. The main known advantage of Julia is its out-of-the-box speed in scientific computation due to its  Just-in-time compiler. This gives a head-start in computational speed compared to C++ and Python which require significantly more complex setups. However, Julia has several other positive aspects that make it especially useful for this project. This includes its strong variable typing, multiple dispatch, and strong support for functional programming. It also incorporates many mathematical tools dealing with matrix operations and numerical equations. For dealing with networks, Graphs.jl was used for generating network classes, such as the Barabasi-Albert and the Watts-Strogatz networks, and for typical graph functionality such as finding path length and nearest neighbors. Karnak.jl was used for network visualization and Plots.jl was used for all the plots in this report.
\subsubsection{Data Structure}
In designing an efficient and scalable data pipeline for epidemic simulations, the choice of data structures plays a critical role. These structures must support both static and dynamic components of the simulation while ensuring memory efficiency and computational speed. This subsection delves into the underlying principles guiding these choices, such as the use of structs, the importance of memory contiguity, and the modularization of code for optimizing computational performance.\\

The aspect that taken under consideration the most in the data structure is Memory contiguity, which refers to the arrangement of data in sequential memory locations. This is important because modern computer architectures leverage caching mechanisms to speed up data retrieval. Contiguous memory allows processors to fetch adjacent data elements in fewer operations, significantly boosting performance for tasks that iterate over large datasets. For epidemic simulations, where data structures like adjacency matrices and population compartments are frequently accessed, maintaining memory contiguity minimizes latency and ensures efficient computational workflows.\\

The struct (short for structure) was used extensively in this project. It is a user-defined composite data type that groups related variables under a single name, allowing them to be accessed and managed as a unit. They play a more bare-bones analog to classes in object-oriented programming. Structs enhance readability, ensure logical grouping, and facilitate passing complex data efficiently between functions while reducing the risk of accidental modifications. However, the most crucial benefit of structs is that they can be static, immutable and of preallocated size. This allows for great compiler optimizations as the reading and writing processes can be streamlined.\\

The usage of structs allows for Modularization in code design, which ensures that computational tasks are divided into smaller, self-contained functions or modules. For epidemic simulations, modularization allows dynamic operations—such as updating epidemiological states or applying travel restrictions—to be isolated within specific functions. These contained spaces reduce the scope of local variables and ensure that memory access patterns remain predictable, leading to optimized resource utilization. Additionally, modularization promotes parallel development and debugging by isolating distinct computational aspects into manageable units.\\

There are two types of data in this sytem: the static parameters and properties of the metapopulation, such as the mobility rate and link weights, and the dynamic data such as the number of infected individuals in each subpopulation and travel restrictions which change with time. The static parameters were stored in a collection of immutable structs such as epidemic and network properties. This grouping allows for safe and efficient passing of constants to functions. It's worthy to note that while there is different link weights between nodes, the network overall is still sparse such that the majority of links between any two nodes are zero-valued. The dynamic variables in this system all happen locally in relation to the subpopulations. The two aspects of this dynamics for any given subpopulation are the sizes of the different epidemiological states and the travel restrictions applied towards all of its neighbors. These dynamic data were stored in structs representing each subpopulation. These include the population compartmental variables and the travel restricitions applied by the subpopulation towards all neighboring populations.\\

The graph structure is stored in the form of a sparse weighted adjacency matrix in the form of a Compressed Sparse Column (CSC).  CSC is composed of 3 arrays of element values, row indices array and column pointers array. CSC was chosed and not Compressed Sparse Row, because Julia is column-major. The storage size of this format is linearly proportional to the number of elements in the adjacency matrix and hence to the network link density. Even though this matrix is symmetrical and thus would only require the storage of the lower rectangular region, the entire matrix is stored with both its symmetric sides. This is to improve the retrieval time to attain the indices of neighboring subpopulations. In a CSC adjacency matrix, values in each column are stored contiguously, and hence are quick to read from memory. However, to maintain this advantage, each column has to be fully stored so that each subpopulation can quickly find all its neighbors.\\

Following the simulation, we are interested in the history of all the dynamic variables. One could store an array copies of the metapopulation, one for each time iteration. However, this data structure would have poor data contiguency. As in the data analysis we will mostly process each variable independently (e.g. looking at the evolution of infected in each subpopulation). Instead, seperate arrays for each of the variables were assigned and appended to with every time step. For the travel restrictions, an array of sparse matrices was stored, where each matrix is the travel restrictions applied from every subpopulation to every other subpopulation. This has the disadvantage that when looking solely on travel restrictions between two subpopulations over time, there is a relatively large span between consecutive time values. However, it was found that reordering the data structure to be a sparse matrix of arrays (where each element is the travel restriction history of a pair of subpopulations) took more time to create than just reading from the array of sparse matrices.\\
\subsubsection{Algorithms}
\subsubsection{Visualization}
\subsection{Simulation Results}